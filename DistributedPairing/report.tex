\documentclass[a4paper,11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{xcolor}

% --- Font Settings ---
\renewcommand\familydefault{\sfdefault}
\usepackage{tgheros}
% zi4 is a high-quality, professional monospaced font available in almost all distributions
\usepackage[varqu]{zi4} 

\usepackage{amsmath,amssymb,amsthm,textcomp}
\usepackage{geometry}
\geometry{left=25mm,right=25mm, top=20mm,bottom=20mm}

\linespread{1.3}
\newcommand{\linia}{\rule{\linewidth}{0.5pt}}

% --- Header and Footer ---
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{}
\lfoot{Distributed Pairing Report}
\cfoot{}
\rfoot{Page \thepage}
\renewcommand{\headrulewidth}{0pt}

% --- Code Listing Settings ---
\usepackage{listings}
\lstset{
    language=Go,
    basicstyle=\ttfamily\small,
    aboveskip={1.0\baselineskip},
    belowskip={1.0\baselineskip},
    columns=fixed,
    extendedchars=true,
    breaklines=true,
    tabsize=4,
    frame=lines,
    keywordstyle=\color[rgb]{0.627,0.126,0.941},
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\color[rgb]{0,0,0},
    numbers=left,
    numberstyle=\small,
    stepnumber=1,
    numbersep=10pt,
    captionpos=t
}

\begin{document}

\begin{center}
    \vspace{2ex}
    {\huge \textsc{Distributed Pairing}}
    \vspace{1ex}
    \\
    \linia\\
    Alessandro Monticelli, Jóhannes Helgi Tómasson, Jonas Stahl \hfill \today
    \vspace{4ex}
\end{center}

\section*{1. Description of the Solution}
% You describe the algorithm, use the proper communication methods, 
% and use the specified shared variables for the result.
To solve the Distributed Pairing problem, we implement an iterative, priority-based, greedy algorithm.
The basic idea behind the developed algorithm is to create a local hierarchy of nodes inside a group of
neighbouring nodes.

Using asyncrhronous messaging through buffered channels, we avoid the use of shared memory. \\
The possible messages in our system are defined as:
\begin{enumerate}
    \item \textbf{\texttt{PROPOSE}:} The sender is asking to pair with the receiver
    \item \textbf{\texttt{ACCEPT}:} The sender is accepting the proposal of the receiver, forming a pair
    \item \textbf{\texttt{MATCHED}:} The sender is communicating it has formed a pair with another node.
\end{enumerate}
Each node has its own state machine, that acts as follows:
\begin{enumerate}
    \item Each \texttt{Node} is initialized as \texttt{SINGLE} (i.e. its \texttt{pair} variable 
    is initialized to the node's ID.), and with a list of its \emph{neighbors}\tiny{(Listing \ref{A} - lines 9-13)}\normalsize.
    \item At each iteration the \texttt{Node} evaulates its position relative to its neighbors\tiny{(Listing \ref{E} - lines 20-24)}\normalsize\:
          \begin{itemize}
              \item If it has the highest \texttt{ID}, it assumes the role of \texttt{proposer}
              \item Otherwise, it acts as a \texttt{listener}
          \end{itemize}
    \item \emph{Proposer:}  Sends a \texttt{PROPOSE} message to its highest-ID neighbor, and waits for a response
                            (Either an \texttt{ACCEPT} or a \texttt{MATCHED} response)\tiny{(Listing \ref{C})}\normalsize.
    \item \emph{Listener:}  Waits for incoming messages, greedily accepting the first incoming proposal, as it is 
                            guaranteed to come from a higher-priority node\tiny{(Listing \ref{D})}\normalsize.
    \item   Once a pair is formed, both the nodes set their \texttt{pair} variable to the respective IDs, and broadcast 
            a \texttt{MATCHED} message to all their active neighbors and terminate\tiny{(Listings \ref{C} - line 12; \ref{D} - line 8)}\normalsize.\\
            If a node receives a \texttt{MATCHED} message from a neighbor, it will remove the ID of the sender from its 
            \texttt{neighbors} list\tiny{(Listings \ref{C} - line 15, \ref{D} - line 9)}\normalsize.
    \item   If a node's \texttt{neighbors} list is empty, it is marked as \texttt{SINGLE} and terminates\tiny{(Listing \ref{E} - lines 4-7)}\normalsize.
\end{enumerate}
\section*{2. Proposed Pseudocode}
\begin{lstlisting}[caption=Distributed Pairing - Node initialization,language=go,label=A]
func InitNode(id, neighbors[], inbox, network) {
	neighborSet := make(map[int]bool)

	for _, n := range neighbors {
		neighborSet[n] = true
	}

	return &Node{
		ID:        id,
		Inbox:     inbox,
		Network:   network,
		neighbors: neighborSet,
		pair:      id,
	}
}
\end{lstlisting}

\begin{lstlisting}[caption=Distributed Pairing - Pair finalization, language=go, label=B]
func (n *Node) finalize(partner_id) {
	// Save partner id in pair.
	n.pair = partner_id

	// Notify all the other neighbors of the new pair.
	for nid := range n.neighbors {
		if nid != partner_id {
			n.send(nid, MATCHED)
		}
	}
}\end{lstlisting}

\newpage
\begin{lstlisting}[caption=Distributed Pairing - Proposer, language=go, label=C]
func (n *Node) propose(target_id) {
	n.send(target_id, PROPOSE)
	// Wait for a response to the proposal
	waiting := true
	while waiting {
		msg := <-n.Inbox
		switch msg.Type {
		case ACCEPT:
			if msg.Sender == target_id {
				// Target has accepted our proposal. Yay!
				n.finalize(target_id)
				return
			}
		case MATCHED:
			// Remove the neighbor from our list, it has already matched.
			delete(n.neighbors, msg.Sender)
			if msg.Sender == target_id {
				// Exit waiting loop and re-evaluate who is the local max
				waiting = false
			}
		}
	}
}
\end{lstlisting}

\begin{lstlisting}[caption=Distributed Pairing - Listener, language=go, label=D]
func (n *Node) listen() {
	msg := <-n.Inbox

	switch msg.Type {
	case PROPOSE:
		// We greedily accept any proposal that comes.
		n.send(msg.Sender, ACCEPT)
		n.finalize(msg.Sender)
	case MATCHED:
		// The sender has been already matched, so we delete it.
		delete(n.neighbors, msg.Sender)
	}
}
\end{lstlisting}

\newpage

\begin{lstlisting}[caption=Distributed Pairing - Make pairs, language=go, label=E]
func (n *Node) makePairs() {
	
	for n.pair == n.ID {
		if len(n.neighbors) == 0 {
            // SINGLE node.
			return
		}

		// We need to find out if we have the highest ID to take priority.
		maxNeighborID := -1

		for id := range n.neighbors {
			if id > maxNeighborID {
				maxNeighborID = id
			}
		}

		haveMaxId := n.ID > maxNeighborID

		if haveMaxId {
			n.propose(maxNeighborID)
		} else {
			n.listen()
		}
	}
}
\end{lstlisting}
\section*{3. Argument of Correctness}
% You demonstrate that the no two neighbouring nodes are single 
% if the algorithm terminates
When the algorithm terminates, there are no adjacent nodes marked as \texttt{SINGLE}. 
This partial correctness can be proven by analyzing the precise conditions under which 
a node definitively terminates in the \texttt{SINGLE} state.

Upon initialization, every node $u$ assumes the \texttt{SINGLE} state by default, setting \texttt{u.pair = u.ID}. 
The process continues to execute its main loop as long as this state remains unchanged 
(i.e., \texttt{for n.pair == n.ID} \tiny{(Listing \ref{E} line 3)}\normalsize).

A node $u$ definitively terminates as \texttt{SINGLE} only if it satisfies the condition: 
\texttt{len(n.neighbors) == 0} \tiny{(Listing \ref{E} line 4)}\normalsize. 
When this occurs, the node executes a \texttt{return} statement and halts 
\tiny{(Listing \ref{E} line 6)}\normalsize. 
Crucially, because it halts immediately without invoking the \texttt{finalize} routine, 
a node terminating as \texttt{SINGLE} never broadcasts a \texttt{MATCHED} message to the network.

Let's assume that two initially adjacent nodes $u$ and $v$ both terminate as \texttt{SINGLE}.
For node $u$ to terminate as \texttt{SINGLE}, its \texttt{neighbors} map must have become empty. 
Since the graph is undirected, $v$ was present in $u$'s map at initialization. 
Therefore, $v$ must have been explicitly removed from $u$'s map during execution.

According to the algorithm's event handling, a neighbor is deleted from the map 
if and only if a \texttt{MATCHED} message is received from that specific neighbor 
\tiny{(Listing \ref{D} line 11)}\normalsize. 
Thus, $u$ must have received a \texttt{MATCHED} message from $v$.However, as established, 
if $v$ terminates as \texttt{SINGLE}, it halts without ever sending a \texttt{MATCHED} message. 
For $v$ to have sent a \texttt{MATCHED} message to $u$, $v$ must have successfully 
paired with some other node $w$ (where $w \neq v$) and executed the \texttt{finalize(w)} routine.

If $v$ paired with $w$, its local state was updated such that \texttt{v.pair = w} 
$\implies$ \texttt{v.pair} $\neq$ \texttt{v.ID}. 
Consequently, $v$ did not terminate as \texttt{SINGLE} and exited its \texttt{makePairs} 
loop \tiny{(Listing \ref{E} line 3)}\normalsize. 
This fundamentally contradicts our initial assumption. Therefore, it is impossible 
for two adjacent nodes to both evaluate empty neighbor maps and terminate as \texttt{SINGLE}.
\section*{4. Termination}
% You give a convincing argument that your algorithm terminates. Reference the code.
The main loop of the algorithm runs as long as a node remains unpaired (i.e., \texttt{for n.pair == n.ID} 
\tiny{(Listing \ref{E} line 3)}\normalsize).
At each iteration, the \texttt{Node} evaluates its position relative to its active neighbors. 
Because the graph is finite and all nodes have strictly unique IDs, there is guaranteed to be 
at least one global maximum ID within any active connected component.

If a node has the highest \texttt{ID} among its neighbors, it assumes the role of 
proposer \tiny{(Listing \ref{E} lines 20-21)}\normalsize.
This proposer sends a \texttt{PROPOSE} message to its highest-ID neighbor, and waits for a 
response \tiny{(Listing \ref{C} line 2)}\normalsize.
Since the receiving neighbor has a lower ID than the proposer, it cannot be a local maximum, 
meaning it must be into the listener state \tiny{(Listing \ref{E} line 23)}\normalsize.
A listener waits for incoming messages, greedily accepting the first incoming proposal 
\tiny{(Listing \ref{D} lines 6-7)}\normalsize.
Once a pair is formed, both the nodes set their \texttt{pair} variable to the respective IDs, 
broadcast a \texttt{MATCHED} message to all active neighbors, and terminate 
\tiny{(Listings \ref{C} line 12; \ref{D} line 8)}\normalsize.

Because at least one global maximum node exists in any non-empty active graph, at least one pair is guaranteed to form in every iteration. This strictly decreases the number of active nodes in the network. Eventually, all nodes will either pair up or find themselves with an empty \texttt{neighbors} list, mark themselves as \texttt{SINGLE} \tiny{(Listing \ref{E} lines 4-6)}\normalsize, and terminate. Thus, the algorithm strictly avoids infinite loops.
\section*{5. Cooperation}
% You give a convincing algorithm that no node waits for messages that are never sent.
For the algorithm to be cooperative, we must guarantee that no node enters a state where it waits 
indefinitely for messages that are never sent. This can be demonstrated by analyzing the waiting states:

\begin{itemize}
    \item The proposer waits for either an \texttt{ACCEPT} 
    or a \texttt{MATCHED} response \tiny{(Listing \ref{C} lines 4-6)}\normalsize. 
    It waits specifically for a response from its \texttt{target\_id}. 
    Because the proposer is a local maximum, its ID is strictly greater than \texttt{target\_id}. 
    Consequently, \texttt{target\_id} cannot be a local maximum and must be executing the 
    \texttt{listen()} routine. 
    A listener greedily accepts the first incoming proposal, as it is guaranteed 
    to come from a higher-priority node \tiny{(Listing \ref{D} line 6)}\normalsize. 
    If the listener had already processed a prior proposal, it would have broadcasted 
    a \texttt{MATCHED} message. In either scenario, a message (\texttt{ACCEPT} or \texttt{MATCHED}) 
    is definitively sent back to the proposer, breaking its waiting loop.
    
    \item A listener blocks on \texttt{<-n.Inbox} 
    waiting for any message \tiny{(Listing \ref{D} line 2)}\normalsize. 
    Because a listener is not a local maximum, it inherently points towards a 
    neighbor with a higher ID. 
    Following this chain guarantees reaching a local maximum node, which is actively proposing. 
    As established in the termination argument, the active network strictly shrinks as pairs form. 
    The listener will inevitably receive either a \texttt{PROPOSE} from a higher-priority node, 
    or \texttt{MATCHED} messages from its neighbors until its map is empty.
\end{itemize}

Finally, note that a proposer only handles \texttt{ACCEPT} and \texttt{MATCHED} messages \tiny{(Listing \ref{C} lines 7-22)}\normalsize. This is safe and cooperative because a proposer holds a local maximum ID; therefore, no active neighbor can view it as a valid proposal target. Consequently, a proposer will never be sent a \texttt{PROPOSE} message while waiting, eliminating the risk of unhandled message deadlocks.
\end{document}
